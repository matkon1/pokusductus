<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>Simple Mobile Controls</title>
  <style>
    /* No diacritics in UI labels if possible */
    :root{
      --bg:#f4f7fb;
      --ground:#d0d7e6;
      --btn-bg: #1f6feb;
      --btn-fg: #fff;
      --ui-size: 72px; /* button size */
    }
    html,body{height:100%;margin:0}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;background:var(--bg);display:flex;align-items:stretch}
    .game-wrap{flex:1;display:flex;flex-direction:column}
    .stage{flex:1;position:relative;overflow:hidden;background:linear-gradient(180deg,#e9f0ff 0%, #f7fbff 60%)}

    /* ground */
    .ground{position:absolute;left:0;right:0;bottom:0;height:110px;background:var(--ground);box-shadow:inset 0 6px 0 rgba(0,0,0,0.02)}

    /* character container */
    #character{position:absolute;left:50%;bottom:110px;transform:translateX(-50%) translateY(0);width:120px;height:120px;will-change:transform}
    #character img{width:100%;height:100%;object-fit:contain;display:block}

    /* simple HUD */
    .hud{position:absolute;top:12px;left:12px;background:rgba(255,255,255,0.85);backdrop-filter:blur(4px);padding:8px 10px;border-radius:10px;font-size:14px}

    /* controls fixed at bottom */
    .controls{position:sticky;bottom:0;background:transparent;padding:12px;display:flex;justify-content:center;align-items:center}
    .dpad{display:flex;gap:8px;align-items:center}
    .dpad .row{display:flex;justify-content:center}

    .btn{width:var(--ui-size);height:var(--ui-size);border-radius:18px;background:var(--btn-bg);color:var(--btn-fg);display:flex;align-items:center;justify-content:center;user-select:none;touch-action:none;font-weight:700;font-size:20px;box-shadow:0 6px 12px rgba(31,111,235,0.18)}
    .btn:active{transform:translateY(2px)}
    .btn--big{width:calc(var(--ui-size) * 1.2);height:calc(var(--ui-size) * 1.2);border-radius:20px}

    /* layout adjustment for larger screens */
    @media(min-width:900px){
      #character{width:160px;height:160px}
      :root{--ui-size:84px}
      .controls{padding:18px}
    }

    /* small help text for desktop */
    .help{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.85);padding:8px;border-radius:10px;font-size:13px}
  </style>
</head>
<body>
  <div class="game-wrap">
    <div class="stage" id="stage" role="application" aria-label="Simple mobile controls stage">
      <div class="hud" id="hud">x: <span id="posx">0</span> y: <span id="posy">0</span></div>
      <div class="help">Use buttons below to move. Works on touch and mouse.</div>

      <!-- character: change MAIN_IMAGE variable in script below to swap image -->
      <div id="character" aria-hidden="false">
        <img id="charImg" src="https://upload.wikimedia.org/wikipedia/commons/8/89/HD_transparent_picture.png" alt="main character">
      </div>

      <div class="ground" aria-hidden="true"></div>
    </div>

    <!-- controls -->
    <div class="controls" id="controls">
      <div class="dpad" aria-hidden="false">
        <div class="row">
          <div class="btn" id="leftBtn" aria-label="left">◀</div>
          <div style="width:8px"></div>
          <div class="btn" id="rightBtn" aria-label="right">▶</div>
        </div>
      </div>
      <div style="width:14px"></div>
      <div style="display:flex;flex-direction:column;gap:8px;align-items:center">
        <div class="btn btn--big" id="jumpBtn" aria-label="jump">▲</div>
        <div class="btn" id="actionBtn" aria-label="action">A</div>
      </div>
    </div>
  </div>

  <script>
    // --------------------------
    // MAIN_IMAGE: change this link to your character image
    // must be an accessible URL (png/webp/jpg). Keep aspect ratio around square.
    const MAIN_IMAGE = 'obr.png';
    // --------------------------

    // init
    const charImg = document.getElementById('charImg');
    charImg.src = MAIN_IMAGE;

    const character = document.getElementById('character');
    const stage = document.getElementById('stage');
    const hudX = document.getElementById('posx');
    const hudY = document.getElementById('posy');

    // position state in pixels relative to stage
    let state = {
      x: stage.clientWidth / 2, // center
      y: 0, // 0 = on ground
      vx: 0,
      vy: 0,
      width: character.clientWidth,
      height: character.clientHeight,
      onGround: true
    };

    // physics
    const GRAVITY = 1600; // px/s^2
    const MOVE_SPEED = 280; // px/s
    const JUMP_V = 620; // px/s

    // input flags
    let input = {left:false,right:false,jump:false,action:false};

    // buttons
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const actionBtn = document.getElementById('actionBtn');

    const bindPointer = (el, onStart, onEnd) => {
      // support touch and mouse
      el.addEventListener('pointerdown', (e)=>{ e.preventDefault(); onStart(); });
      window.addEventListener('pointerup', (e)=>{ onEnd(); });
      // also cancel on lost pointer
      el.addEventListener('pointercancel', (e)=>{ onEnd(); });
    };

    bindPointer(leftBtn, ()=> input.left = true, ()=> input.left = false);
    bindPointer(rightBtn, ()=> input.right = true, ()=> input.right = false);
    bindPointer(jumpBtn, ()=> { if(state.onGround){ input.jump = true; } }, ()=> { input.jump = false });
    bindPointer(actionBtn, ()=> { input.action = true; setTimeout(()=> input.action = false, 120); }, ()=> { input.action = false });

    // resize handler to keep reference sizes
    const onResize = ()=>{
      state.width = character.clientWidth;
      state.height = character.clientHeight;
      // ensure x within bounds
      state.x = Math.min(Math.max(state.x, state.width/2), stage.clientWidth - state.width/2);
      render(true);
    };
    window.addEventListener('resize', onResize);

    // main loop
    let last = performance.now();
    function loop(ts){
      const dt = Math.min((ts - last)/1000, 0.05);
      last = ts;

      // horizontal movement
      let targetVx = 0;
      if(input.left) targetVx -= MOVE_SPEED;
      if(input.right) targetVx += MOVE_SPEED;

      // simple accel
      const ACC = 3000;
      if(state.vx < targetVx) state.vx = Math.min(state.vx + ACC*dt, targetVx);
      if(state.vx > targetVx) state.vx = Math.max(state.vx - ACC*dt, targetVx);

      // jump
      if(input.jump && state.onGround){
        state.vy = -JUMP_V;
        state.onGround = false;
        input.jump = false;
      }

      // gravity
      state.vy += GRAVITY * dt;

      // integrate
      state.x += state.vx * dt;
      state.y += state.vy * dt;

      // ground collision
      const groundY = 0; // y=0 means on ground bottom offset
      const maxY = stage.clientHeight - state.height - 110; // 110 = ground height
      // we use state.y measured from ground upward being 0 when on ground; but above we increased y with vy
      if(state.y > 0){
        // on ground
        state.y = 0;
        state.vy = 0;
        state.onGround = true;
      }

      // clamp horizontal
      const halfW = state.width/2;
      state.x = Math.min(Math.max(state.x, halfW), stage.clientWidth - halfW);

      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function render(force){
      // convert state.x (px from left) and state.y (0 on ground, positive up) to css transform
      const px = state.x;
      const groundOffset = 110 + state.height; // bottom offset
      const transY = -state.y; // since state.y = 0 on ground, negative translateY moves up
      character.style.transform = `translateX(${px - stage.clientWidth/2}px) translateY(${ - (state.y)}px)`;

      hudX.textContent = Math.round(state.x);
      hudY.textContent = Math.round(state.y);

      // flip image based on direction
      if(state.vx < -10) charImg.style.transform = 'scaleX(-1)';
      else if(state.vx > 10) charImg.style.transform = 'scaleX(1)';

      // simple action visual feedback
      if(input.action){ character.style.filter = 'brightness(1.08) saturate(1.08)'; }
      else character.style.filter = '';
    }

    // set initial x to center
    function init(){
      state.x = stage.clientWidth/2;
      state.y = 0;
      onResize();
    }
    init();

    // prevent default gestures that interfere on mobile
    document.addEventListener('touchmove', function(e){ if(e.scale !== 1) e.preventDefault(); }, {passive:false});

    // small keyboard fallback for desktop (optional) - kept minimal and not required by user
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft') input.left = true;
      if(e.key === 'ArrowRight') input.right = true;
      if(e.key === ' ' || e.key === 'ArrowUp') { if(state.onGround) input.jump = true; }
    });
    window.addEventListener('keyup', (e)=>{
      if(e.key === 'ArrowLeft') input.left = false;
      if(e.key === 'ArrowRight') input.right = false;
    });

  </script>
</body>
</html>
